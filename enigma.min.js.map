{"version":3,"file":"enigma.min.js","sources":["src/json-patch.js","node_modules/node-event-emitter/index.js","src/schema.js","node_modules/extend/index.js","src/event-emitter.js","src/session.js","src/cache.js","src/rpc-resolver.js","src/rpc.js","src/suspend-resume.js","src/intercept.js","src/api-cache.js","src/qix.js"],"sourcesContent":["import originalExtend from 'extend';\n\nconst extend = originalExtend.bind(null, true);\nconst JSONPatch = {};\nconst isArray = Array.isArray;\nfunction isObject(v) { return v != null && !Array.isArray(v) && typeof v === 'object'; }\nfunction isUndef(v) { return typeof v === 'undefined'; }\nfunction isFunction(v) { return typeof v === 'function'; }\n\n/**\n* Generate an exact duplicate (with no references) of a specific value.\n*\n* @private\n* @param {Object} The value to duplicate\n* @returns {Object} a unique, duplicated value\n*/\nfunction generateValue(val) {\n  if (val) {\n    val = extend({}, { val }).val;\n  }\n  return val;\n}\n\n/**\n* An additional type checker used to determine if the property is of internal\n* use or not a type that can be translated into JSON (like functions).\n*\n* @private\n* @param {Object} obj The object which has the property to check\n* @param {String} The property name to check\n* @returns {Boolean} Whether the property is deemed special or not\n*/\nfunction isSpecialProperty(obj, key) {\n  return isFunction(obj[key]) ||\n    key.substring(0, 2) === '$$' ||\n    key.substring(0, 1) === '_';\n}\n\n/**\n* Finds the parent object from a JSON-Pointer (\"/foo/bar/baz\" = \"bar\" is \"baz\" parent),\n* also creates the object structure needed.\n*\n* @private\n* @param {Object} data The root object to traverse through\n* @param {String} The JSON-Pointer string to use when traversing\n* @returns {Object} The parent object\n*/\nfunction getParent(data, str) {\n  const seperator = '/';\n  const parts = str.substring(1).split(seperator).slice(0, -1);\n  let numPart;\n\n  parts.forEach((part, i) => {\n    if (i === parts.length) {\n      return;\n    }\n    numPart = +part;\n    const newPart = !isNaN(numPart) ? [] : {};\n    data[numPart || part] = isUndef(data[numPart || part]) ?\n      newPart :\n      data[part];\n    data = data[numPart || part];\n  });\n\n  return data;\n}\n\n/**\n* Cleans an object of all its properties, unless they're deemed special or\n* cannot be removed by configuration.\n*\n* @private\n* @param {Object} obj The object to clean\n*/\nfunction emptyObject(obj) {\n  Object.keys(obj).forEach((key) => {\n    const config = Object.getOwnPropertyDescriptor(obj, key);\n\n    if (config.configurable && !isSpecialProperty(obj, key)) {\n      delete obj[key];\n    }\n  });\n}\n\n/**\n* Compare an object with another, could be object, array, number, string, bool.\n*\n* @param {Object} a The first object to compare\n* @param {Object} a The second object to compare\n* @returns {Boolean} Whether the objects are identical\n*/\nfunction compare(a, b) {\n  let isIdentical = true;\n\n  if (isObject(a) && isObject(b)) {\n    if (Object.keys(a).length !== Object.keys(b).length) {\n      return false;\n    }\n    Object.keys(a).forEach((key) => {\n      if (!compare(a[key], b[key])) {\n        isIdentical = false;\n      }\n    });\n    return isIdentical;\n  } else if (isArray(a) && isArray(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (let i = 0, l = a.length; i < l; i += 1) {\n      if (!compare(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return a === b;\n}\n\n/**\n* Generates patches by comparing two arrays.\n*\n* @private\n* @param {Array} oldA The old (original) array, which will be patched\n* @param {Array} newA The new array, which will be used to compare against\n* @returns {Array} An array of patches (if any)\n*/\nfunction patchArray(original, newA, basePath) {\n  let patches = [];\n  const oldA = original.slice();\n  let tmpIdx = -1;\n\n  function findIndex(a, id, idx) {\n    if (a[idx] && isUndef(a[idx].qInfo)) {\n      return null;\n    } else if (a[idx] && a[idx].qInfo.qId === id) {\n      // shortcut if identical\n      return idx;\n    }\n    for (let ii = 0, ll = a.length; ii < ll; ii += 1) {\n      if (a[ii] && a[ii].qInfo.qId === id) {\n        return ii;\n      }\n    }\n    return -1;\n  }\n\n  if (compare(newA, oldA)) {\n    // array is unchanged\n    return patches;\n  }\n\n  if (!isUndef(newA[0]) && isUndef(newA[0].qInfo)) {\n    // we cannot create patches without unique identifiers, replace array...\n    patches.push({\n      op: 'replace',\n      path: basePath,\n      value: newA,\n    });\n    return patches;\n  }\n\n  for (let i = oldA.length - 1; i >= 0; i -= 1) {\n    tmpIdx = findIndex(newA, oldA[i].qInfo && oldA[i].qInfo.qId, i);\n    if (tmpIdx === -1) {\n      patches.push({\n        op: 'remove',\n        path: `${basePath}/${i}`,\n      });\n      oldA.splice(i, 1);\n    } else {\n      patches = patches.concat(JSONPatch.generate(oldA[i], newA[tmpIdx], `${basePath}/${i}`));\n    }\n  }\n\n  for (let i = 0, l = newA.length; i < l; i += 1) {\n    tmpIdx = findIndex(oldA, newA[i].qInfo && newA[i].qInfo.qId);\n    if (tmpIdx === -1) {\n      patches.push({\n        op: 'add',\n        path: `${basePath}/${i}`,\n        value: newA[i],\n      });\n      oldA.splice(i, 0, newA[i]);\n    } else if (tmpIdx !== i) {\n      patches.push({\n        op: 'move',\n        path: `${basePath}/${i}`,\n        from: `${basePath}/${tmpIdx}`,\n      });\n      oldA.splice(i, 0, oldA.splice(tmpIdx, 1)[0]);\n    }\n  }\n  return patches;\n}\n\n/**\n* Generate an array of JSON-Patch:es following the JSON-Patch Specification Draft.\n*\n* See [specification draft](http://tools.ietf.org/html/draft-ietf-appsawg-json-patch-10)\n*\n* Does NOT currently generate patches for arrays (will replace them)\n*\n* @param {Object} original The object to patch to\n* @param {Object} newData The object to patch from\n* @param {String} [basePath] The base path to use when generating the paths for\n*                            the patches (normally not used)\n* @returns {Array} An array of patches\n*/\nJSONPatch.generate = function generate(original, newData, basePath) {\n  basePath = basePath || '';\n  let patches = [];\n\n  Object.keys(newData).forEach((key) => {\n    const val = generateValue(newData[key]);\n    const oldVal = original[key];\n    const tmpPath = `${basePath}/${key}`;\n\n    if (compare(val, oldVal) || isSpecialProperty(newData, key)) {\n      return;\n    }\n    if (isUndef(oldVal)) {\n      // property does not previously exist\n      patches.push({\n        op: 'add',\n        path: tmpPath,\n        value: val,\n      });\n    } else if (isObject(val) && isObject(oldVal)) {\n      // we need to generate sub-patches for this, since it already exist\n      patches = patches.concat(JSONPatch.generate(oldVal, val, tmpPath));\n    } else if (isArray(val) && isArray(oldVal)) {\n      patches = patches.concat(patchArray(oldVal, val, tmpPath));\n    } else {\n      // it's a simple property (bool, string, number)\n      patches.push({\n        op: 'replace',\n        path: `${basePath}/${key}`,\n        value: val,\n      });\n    }\n  });\n\n  Object.keys(original).forEach((key) => {\n    if (isUndef(newData[key]) && !isSpecialProperty(original, key)) {\n      // this property does not exist anymore\n      patches.push({\n        op: 'remove',\n        path: `${basePath}/${key}`,\n      });\n    }\n  });\n\n  return patches;\n};\n\n/**\n* Apply a list of patches to an object.\n*\n* @param {Object} original The object to patch\n* @param {Array} patches The list of patches to apply\n*/\nJSONPatch.apply = function apply(original, patches) {\n  patches.forEach((patch) => {\n    let parent = getParent(original, patch.path);\n    let key = patch.path.split('/').splice(-1)[0];\n    let target = key && isNaN(+key) ? parent[key] : parent[+key] || parent;\n    const from = patch.from ? patch.from.split('/').splice(-1)[0] : null;\n\n    if (patch.path === '/') {\n      parent = null;\n      target = original;\n    }\n\n    if (patch.op === 'add' || patch.op === 'replace') {\n      if (isArray(parent)) {\n        // trust indexes from patches, so don't replace the index if it's an add\n        if (key === '-') {\n          key = parent.length;\n        }\n        parent.splice(+key, patch.op === 'add' ? 0 : 1, patch.value);\n      } else if (isArray(target) && isArray(patch.value)) {\n        const newValues = patch.value.slice();\n        // keep array reference if possible...\n        target.length = 0;\n        target.push(...newValues);\n      } else if (isObject(target) && isObject(patch.value)) {\n        // keep object reference if possible...\n        emptyObject(target);\n        extend(target, patch.value);\n      } else if (!parent) {\n        throw new Error('Patchee is not an object we can patch');\n      } else {\n        // simple value\n        parent[key] = patch.value;\n      }\n    } else if (patch.op === 'move') {\n      const oldParent = getParent(original, patch.from);\n      if (isArray(parent)) {\n        parent.splice(+key, 0, oldParent.splice(+from, 1)[0]);\n      } else {\n        parent[key] = oldParent[from];\n        delete oldParent[from];\n      }\n    } else if (patch.op === 'remove') {\n      if (isArray(parent)) {\n        parent.splice(+key, 1);\n      } else {\n        delete parent[key];\n      }\n    }\n  });\n};\n\n/**\n* Deep clone an object.\n*\n* @param {Object} obj The object to clone\n* @returns {Object} A new object identical to the `obj`\n*/\nJSONPatch.clone = function clone(obj) {\n  return extend({}, obj);\n};\n\n/**\n* Creates a JSON-patch.\n*\n* @param {String} op The operation of the patch. Available values: \"add\", \"remove\", \"move\"\n* @param {Object} [val] The value to set the `path` to. If `op` is `move`, `val`\n*                       is the \"from JSON-path\" path\n* @param {String} path The JSON-path for the property to change (e.g. \"/qHyperCubeDef/columnOrder\")\n* @returns {Object} A patch following the JSON-patch specification\n*/\nJSONPatch.createPatch = function createPatch(op, val, path) {\n  const patch = {\n    op: op.toLowerCase(),\n    path,\n  };\n  if (patch.op === 'move') {\n    patch.from = val;\n  } else if (typeof val !== 'undefined') {\n    patch.value = val;\n  }\n  return patch;\n};\n\n/**\n* Apply the differences of two objects (keeping references if possible).\n* Identical to running `JSONPatch.apply(original, JSONPatch.generate(original, newData));`\n*\n* @param {Object} original The object to update/patch\n* @param {Object} newData the object to diff against\n*\n* @example\n* var obj1 = { foo: [1,2,3], bar: { baz: true, qux: 1 } };\n* var obj2 = { foo: [4,5,6], bar: { baz: false } };\n* JSONPatch.updateObject(obj1, obj2);\n* // => { foo: [4,5,6], bar: { baz: false } };\n*/\nJSONPatch.updateObject = function updateObject(original, newData) {\n  if (!Object.keys(original).length) {\n    extend(original, newData);\n    return;\n  }\n  JSONPatch.apply(original, JSONPatch.generate(original, newData));\n};\n\nexport default JSONPatch;\n","/**\n * Utility functions\n */\n\nvar util = {};\n\nutil.isObject = function isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nutil.isNumber = function isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nutil.isUndefined = function isUndefined(arg) {\n  return arg === void 0;\n}\n\nutil.isFunction = function isFunction(arg){\n  return typeof arg === 'function';\n}\n\n\n/**\n * EventEmitter class\n */\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\nEventEmitter.init = function() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!util.isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error' && !this._events.error) {\n    er = arguments[1];\n    if (er instanceof Error) {\n      throw er; // Unhandled 'error' event\n    } else {\n      throw Error('Uncaught, unspecified \"error\" event.');\n    }\n    return false;\n  }\n\n  handler = this._events[type];\n\n  if (util.isUndefined(handler))\n    return false;\n\n  if (util.isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        len = arguments.length;\n        args = new Array(len - 1);\n        for (i = 1; i < len; i++)\n          args[i - 1] = arguments[i];\n        handler.apply(this, args);\n    }\n  } else if (util.isObject(handler)) {\n    len = arguments.length;\n    args = new Array(len - 1);\n    for (i = 1; i < len; i++)\n      args[i - 1] = arguments[i];\n\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!util.isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              util.isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (util.isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (util.isObject(this._events[type]) && !this._events[type].warned) {\n    var m;\n    if (!util.isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n\n      if (util.isFunction(console.error)) {\n        console.error('(node) warning: possible EventEmitter memory ' +\n                      'leak detected. %d listeners added. ' +\n                      'Use emitter.setMaxListeners() to increase limit.',\n                      this._events[type].length);\n      }\n      if (util.isFunction(console.trace))\n        console.trace();\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!util.isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!util.isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (util.isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (util.isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (util.isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (Array.isArray(listeners)) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (util.isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (util.isFunction(emitter._events[type]))\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n","import KeyValueCache from './cache';\nimport Events from './event-emitter';\n\nconst IGNORE_DELTA_METHODS = [\n  'GetProperties',\n  'SetProperties',\n  'GetFullPropertyTree',\n  'SetFullPropertyTree',\n  'GetAppProperties',\n  'SetAppProperties',\n];\n\nconst SUCCESS_KEY = 'qSuccess';\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n* Returns the camelCase counterpart of a symbol.\n* @param {String} symbol The symbol.\n* @return the camelCase counterpart.\n*/\nfunction toCamelCase(symbol) {\n  return symbol.substring(0, 1).toLowerCase() + symbol.substring(1);\n}\n\n/**\n * A facade function that allows parameters to be passed either by name\n * (through an object), or by position (through an array).\n * @param {Function} base The function that is being overriden. Will be\n *                        called with parameters in array-form.\n * @param {Object} defaults Parameter list and it's default values.\n * @param {*} params The parameters.\n */\nfunction namedParamFacade(base, defaults, ...params) {\n  if (params.length === 1 && typeof params[0] === 'object') {\n    const valid = Object.keys(params[0]).every(key => hasOwnProperty.call(defaults, key));\n    if (valid) {\n      params = Object.keys(defaults).map(key => params[0][key] || defaults[key]);\n    }\n  }\n  return base.apply(this, params);\n}\n\n/**\n* Qix schema definition.\n*/\nclass Schema {\n\n  /**\n  * Create a new schema instance.\n  * @param {Configuration} config The configuration for QIX.\n  */\n  constructor(config) {\n    this.config = config;\n    this.Promise = config.Promise;\n    this.schema = config.schema;\n    this.mixins = new KeyValueCache();\n    this.types = new KeyValueCache();\n  }\n\n  /**\n  * Function used to add a mixin object to the mixin cache. Will be mixed into the API\n  * of the specified key when generated.\n  * @param {Object} mixin Mixin object.\n  * @param {String|Array<String>} mixin.types String or array of strings containing the\n  *                                           API-types that will be mixed in.\n  * @param {Object} [mixin.extend] Object literal containing the methods that\n  *                                will be extended on the specified API.\n  * @param {Object} [mixin.override] Object literal containing the methods to\n  *                                  override existing methods.\n  * @param {Function} [mixin.init] Init function that, if defined, will run when an API is\n  *                                instantiated. It runs with Promise and API object as parameters.\n  */\n  registerMixin({ types, type, extend, override, init }) {\n    if (!Array.isArray(types)) {\n      types = [types];\n    }\n    // to support a single type\n    if (type) {\n      types.push(type);\n    }\n    const cached = { extend, override, init };\n    types.forEach((typeKey) => {\n      const entryList = this.mixins.get(typeKey);\n      if (entryList) {\n        entryList.push(cached);\n      } else {\n        this.mixins.add(typeKey, [cached]);\n      }\n    });\n  }\n\n  /**\n  * Function used to generate a type definition.\n  * @param {String} type The type.\n  * @returns {{create: Function, def: Object}} Returns an object with a definition\n  *          of the type and a create factory.\n  */\n  generate(type) {\n    const entry = this.types.get(type);\n    if (entry) {\n      return entry;\n    }\n    if (!this.schema.structs[type]) {\n      throw new Error(`${type} not found`);\n    }\n    const factory = this.generateApi(type, this.schema.structs[type]);\n    this.types.add(type, factory);\n    return factory;\n  }\n\n  /**\n  * Function used to generate an API definition for a given type.\n  * @param {String} type The type to generate.\n  * @param {Object} schema The schema describing the type.\n  * @returns {{create: (function(session:Object, handle:Number, id:String,\n  *          delta:Boolean, customKey:String)), def: Object}} Returns the API definition.\n  */\n  generateApi(type, schema) {\n    const api = Object.create({});\n\n    this.generateDefaultApi(api, schema); // Generate default\n    this.mixinType(type, api); // Mixin default type\n    this.mixinNamedParamFacade(api, schema); // Mixin named parameter support\n\n    const create = function create(session, handle, id, delta, customKey) {\n      const instance = Object.create(api);\n\n      Events.mixin(instance); // Always mixin event-emitter per instance\n\n      Object.defineProperties(instance, {\n        session: {\n          enumerable: true,\n          value: session,\n        },\n        handle: {\n          enumerable: true,\n          value: handle,\n          writable: true,\n        },\n        id: {\n          enumerable: true,\n          value: id,\n        },\n        delta: {\n          enumerable: true,\n          value: delta,\n        },\n        type: {\n          enumerable: true,\n          value: type,\n        },\n        genericType: {\n          enumerable: true,\n          value: customKey,\n        },\n      });\n\n      let mixinList = this.mixins.get(type) || [];\n      if (customKey !== type) {\n        this.mixinType(customKey, instance); // Mixin custom types\n        mixinList = mixinList.concat(this.mixins.get(customKey) || []);\n      }\n      mixinList.forEach((mixin) => {\n        if (typeof mixin.init === 'function') {\n          mixin.init({ config: this.config, api: instance });\n        }\n      });\n\n      return instance;\n    }.bind(this);\n\n    return {\n      create,\n      def: api,\n    };\n  }\n\n  /**\n  * Function used to generate the methods with the right handlers to the object\n  * API that is being generated.\n  * @param {Object} api The object API that is currently being generated.\n  * @param {Object} schema The API definition.\n  */\n  generateDefaultApi(api, schema) {\n    Object.keys(schema).forEach((key) => {\n      const fnName = toCamelCase(key);\n      const outKey = schema[key].Out && schema[key].Out.length === 1 ? schema[key].Out[0].Name : -1;\n\n      const allowDelta = IGNORE_DELTA_METHODS.indexOf(key) === -1 &&\n        outKey !== -1 &&\n        outKey !== SUCCESS_KEY;\n\n      function fn(...params) {\n        return this.session.send({\n          method: key,\n          handle: this.handle,\n          params,\n          delta: this.delta && allowDelta,\n          outKey,\n        });\n      }\n\n      Object.defineProperty(api, fnName, {\n        enumerable: true,\n        writable: true,\n        value: fn,\n      });\n    });\n  }\n\n  /**\n  * Function used to add mixin methods to a specified API.\n  * @param {String} type Used to specify which mixin should be woven in.\n  * @param {Object} api The object that will be woven.\n  */\n  mixinType(type, api) {\n    const mixinList = this.mixins.get(type);\n    if (mixinList) {\n      mixinList.forEach(({ extend = {}, override = {} }) => {\n        Object.keys(override).forEach((key) => {\n          if (typeof api[key] === 'function' && typeof override[key] === 'function') {\n            const baseFn = api[key];\n            api[key] = function wrappedFn(...args) {\n              return override[key].apply(this, [baseFn.bind(this), ...args]);\n            };\n          } else {\n            throw new Error(`No function to override. Type: ${type} function: ${key}`);\n          }\n        });\n        Object.keys(extend).forEach((key) => {\n          // handle overrides\n          if (typeof api[key] === 'function' && typeof extend[key] === 'function') {\n            throw new Error(`Extend is not allowed for this mixin. Type: ${type} function: ${key}`);\n          } else {\n            api[key] = extend[key];\n          }\n        });\n      });\n    }\n  }\n\n  /**\n  * Function used to mixin the named parameter facade.\n  * @param {Object} api The object API that is currently being generated.\n  * @param {Object} schema The API definition.\n  */\n  mixinNamedParamFacade(api, schema) {\n    Object.keys(schema).forEach((key) => {\n      const fnName = toCamelCase(key);\n      const base = api[fnName];\n      const defaults = schema[key].In.reduce((result, item) => {\n        result[item.Name] = item.DefaultValue;\n        return result;\n      }, {});\n\n      api[fnName] = function namedParamWrapper(...params) {\n        return namedParamFacade.apply(this, [base, defaults, ...params]);\n      };\n    });\n  }\n}\n\nexport default Schema;\n","'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) { /**/ }\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone;\n\tvar target = arguments[0];\n\tvar i = 1;\n\tvar length = arguments.length;\n\tvar deep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\tif (target == null || (typeof target !== 'object' && typeof target !== 'function')) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = target[name];\n\t\t\t\tcopy = options[name];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\ttarget[name] = extend(deep, clone, copy);\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\ttarget[name] = copy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n","import EventEmitter from 'node-event-emitter';\n\n/**\n* @module EventEmitter\n*/\nexport default {\n\n  /**\n  * Function used to add event handling to objects passed in.\n  * @param {Object} obj Object instance that will get event handling.\n  */\n  mixin: (obj) => {\n    Object.keys(EventEmitter.prototype).forEach((key) => {\n      obj[key] = EventEmitter.prototype[key];\n    });\n    EventEmitter.init(obj);\n  },\n};\n","import EventEmitter from './event-emitter';\n\nconst RPC_CLOSE_NORMAL = 1000;\nconst RPC_CLOSE_MANUAL_SUSPEND = 4000;\n\nclass Session {\n  /**\n  * Creates a new Session instance.\n  * @param {Object} options The configuration option for this class.\n  * @param {Intercept} options.intercept The intercept instance to use.\n  * @param {ApiCache} options.apis The ApiCache instance to bridge events towards.\n  * @param {Promise} options.Promise The promise constructor to use.\n  * @param {RPC} options.rpc The RPC instance to use when communicating towards Engine.\n  * @param {Schema} options.definition The Schema instance to use when generating APIs.\n  * @param {Object} options.protocol Additional protocol properties.\n  * @param {Boolean} options.protocol.delta Flag indicating if delta should be used or not.\n  * @param {SuspendResume} options.suspendResume The SuspendResume instance to use.\n  * @param {Object} [options.eventListeners] An object containing keys (event names) and\n  *                                          values (event handlers) that will be bound\n  *                                          during instantiation.\n  */\n  constructor(options) {\n    const session = this;\n    Object.assign(session, options);\n    EventEmitter.mixin(session);\n    session.rpc.on('socket-error', session.onError.bind(session));\n    session.rpc.on('closed', session.onClosed.bind(session));\n    session.rpc.on('message', session.onMessage.bind(session));\n    session.rpc.on('notification', session.onNotification.bind(session));\n    session.rpc.on('traffic', session.onTraffic.bind(session));\n    session.on('handle:changed', handle => session.apis.onHandleChanged(handle));\n    session.on('handle:closed', handle => session.apis.onHandleClosed(handle));\n    session.on('closed', () => session.apis.onSessionClosed());\n  }\n\n  /**\n  * Event handler for re-triggering error events from RPC.\n  * @emits socket-error\n  * @param {Error} err Webocket error event.\n  */\n  onError(err) {\n    if (this.suspendResume.isSuspended) {\n      return;\n    }\n    this.emit('socket-error', err);\n  }\n\n  /**\n  * Event handler for the RPC close event.\n  * @emits suspended\n  * @emits closed\n  * @param {Event} evt WebSocket close event.\n  */\n  onClosed(evt) {\n    if (this.suspendResume.isSuspended) {\n      return;\n    }\n    if (evt.code === RPC_CLOSE_NORMAL || evt.code === RPC_CLOSE_MANUAL_SUSPEND) {\n      return;\n    }\n    if (this.suspendOnClose) {\n      this.suspendResume.suspend().then(() => this.emit('suspended', { initiator: 'network' }));\n    } else {\n      this.emit('closed', evt);\n    }\n  }\n\n  /**\n  * Event handler for the RPC message event.\n  * @emits handle:changed\n  * @emits handle:closed\n  * @param {Object} response JSONRPC response.\n  */\n  onMessage(response) {\n    if (this.suspendResume.isSuspended) {\n      return;\n    }\n    if (response.change) {\n      response.change.forEach(handle => this.emit('handle:changed', handle));\n    }\n    if (response.close) {\n      response.close.forEach(handle => this.emit('handle:closed', handle));\n    }\n  }\n\n  /**\n  * Event handler for the RPC notification event.\n  * @emits notification:*\n  * @emits notification:[JSONRPC notification name]\n  * @param {Object} response The JSONRPC notification.\n  */\n  onNotification(response) {\n    this.emit('notification:*', response.method, response.params);\n    this.emit(`notification:${response.method}`, response.params);\n  }\n\n  /**\n  * Event handler for the RPC traffic event.\n  * @emits traffic:*\n  * @emits traffic:sent\n  * @emits traffic:received\n  * @param {String} dir The traffic direction, sent or received.\n  * @param {Object} data JSONRPC request/response/WebSocket message.\n  */\n  onTraffic(dir, data) {\n    this.emit('traffic:*', dir, data);\n    this.emit(`traffic:${dir}`, data);\n  }\n\n  /**\n  * Function used to get an API for a backend object.\n  * @param {Object} args Arguments used to create object API.\n  * @param {Number} args.handle Handle of the backend object.\n  * @param {String} args.id ID of the backend object.\n  * @param {String} args.type QIX type of the backend object. Can for example\n  *                           be \"Doc\" or \"GenericVariable\".\n  * @param {String} args.customType Custom type of the backend object, if defined in qInfo.\n  * @returns {*} Returns the generated and possibly augmented API.\n  */\n  getObjectApi(args) {\n    const { handle, id, type, customType } = args;\n    let api = this.apis.getApi(handle);\n    if (api) {\n      return api;\n    }\n    api = this.definition\n      .generate(type)\n      .create(this, handle, id, this.protocol.delta, customType);\n    this.apis.add(handle, api);\n    return api;\n  }\n\n  /**\n  * Response handler for generating APIs. Handles the quirks of engine not returning an error\n  * when an object is missing.\n  * @param {Object} response The response message.\n  * @returns {Promise} A promise that resolves with the created object.\n  */\n  handleObjectReferenceResponse(response) {\n    if (response.qHandle && response.qType) {\n      return this.getObjectApi({\n        handle: response.qHandle,\n        type: response.qType,\n        id: response.qGenericId,\n        customType: response.qGenericType,\n      });\n    }\n    return this.Promise.reject(new Error('Object not found'));\n  }\n\n  /**\n  * Establishes the RPC socket connection and returns the Global instance.\n  * @returns {Promise} Eventually resolved if the connection was successful.\n  */\n  open() {\n    if (!this.globalPromise) {\n      const args = { handle: -1, id: 'Global', type: 'Global', customType: 'Global' };\n      this.globalPromise = this.rpc.open()\n        .then(() => this.getObjectApi(args))\n        .then((global) => {\n          this.emit('opened');\n          return global;\n        });\n    }\n    return this.globalPromise;\n  }\n\n  /**\n  * Function used to send data on the RPC socket.\n  * @param {Object} request - The request to be sent. (data and some meta info)\n  * @returns {Object} Returns a promise instance.\n  */\n  send(request) {\n    if (this.suspendResume.isSuspended) {\n      return this.Promise.reject(new Error('Session suspended'));\n    }\n    const data = Object.assign({}, this.protocol, {\n      method: request.method,\n      handle: request.handle,\n      params: request.params,\n      delta: request.delta,\n    });\n    const response = this.rpc.send(data);\n    request.id = data.id;\n\n    const promise = this.intercept.execute(response, request).then((res) => {\n      if (typeof res.qHandle !== 'undefined' && typeof res.qType !== 'undefined') {\n        return this.handleObjectReferenceResponse(res);\n      }\n      return res;\n    });\n    Session.addToPromiseChain(promise, 'requestId', request.id);\n    return promise;\n  }\n\n  /**\n  * Suspends the session (\"sleeping state\"), and closes the RPC connection.\n  * @emits suspended\n  * @returns {Promise} Eventually resolved when the RPC connection is closed.\n  */\n  suspend() {\n    return this.suspendResume.suspend()\n      .then(() => this.emit('suspended', { initiator: 'manual' }));\n  }\n\n  /**\n  * Resumes a previously suspended session.\n  * @param {Boolean} onlyIfAttached - if true, resume only if the session was re-attached.\n  * @returns {Promise} Eventually resolved if the session was successfully resumed,\n  *                    otherwise rejected.\n  */\n  resume(onlyIfAttached) {\n    return this.suspendResume.resume(onlyIfAttached).then((value) => {\n      this.emit('resumed');\n      return value;\n    });\n  }\n\n  /**\n  * Function used to close the session.\n  * @returns {Promise} Eventually resolved when the RPC connection is closed.\n  */\n  close() {\n    this.globalPromise = undefined;\n    return this.rpc.close().then(evt => this.emit('closed', evt));\n  }\n\n  /**\n  * Function used to add info on the promise chain.\n  * @private\n  * @param {Promise} promise The promise to add info on.\n  * @param {String} name The property to add info on.\n  * @param {Any} value The info to add.\n  */\n  static addToPromiseChain(promise, name, value) {\n    promise[name] = value;\n    const then = promise.then;\n    promise.then = function patchedThen(...params) {\n      const chain = then.apply(this, params);\n      Session.addToPromiseChain(chain, name, value);\n      return chain;\n    };\n  }\n}\n\nexport default Session;\n","/**\n* Key-value cache\n*/\nclass KeyValueCache {\n\n  constructor() {\n    this.entries = {};\n  }\n\n  /**\n  * Adds an entry.\n  * @function KeyValueCache#add\n  * @param {String} key The key representing an entry.\n  * @param {*} entry The entry to be added.\n  */\n  add(key, entry) {\n    key += '';\n    if (typeof this.entries[key] !== 'undefined') {\n      throw new Error(`Entry already defined with key ${key}`);\n    }\n    this.entries[key] = entry;\n  }\n\n  /**\n  * Sets an entry.\n  * @function KeyValueCache#set\n  * @param {String} key The key representing an entry.\n  * @param {*} entry The entry.\n  */\n  set(key, entry) {\n    key += '';\n    this.entries[key] = entry;\n  }\n\n  /**\n  * Removes an entry.\n  * @function KeyValueCache#remove\n  * @param {String} key The key representing an entry.\n  */\n  remove(key) {\n    delete this.entries[key];\n  }\n\n  /**\n  * Gets an entry.\n  * @function KeyValueCache#get\n  * @param {String} key The key representing an entry.\n  * @returns {*} The entry for the key.\n  */\n  get(key) {\n    return this.entries[key];\n  }\n\n  /**\n  * Gets a list of all entries.\n  * @function KeyValueCache#getAll\n  * @returns {Array} The list of entries including its `key` and `value` properties.\n  */\n  getAll() {\n    return Object.keys(this.entries).map(key =>\n      ({\n        key,\n        value: this.entries[key],\n      }),\n    );\n  }\n\n  /**\n  * Gets a key for an entry.\n  * @function KeyValueCache#getKey\n  * @param {*} entry The entry to locate the key for.\n  * @returns {String} The key representing an entry.\n  */\n  getKey(entry) {\n    return Object.keys(this.entries).filter(key =>\n      this.entries[key] === entry,\n    )[0];\n  }\n\n  /**\n  * Clears the cache of all entries.\n  * @function KeyValueCache#clear\n  */\n  clear() {\n    this.entries = {};\n  }\n}\n\nexport default KeyValueCache;\n","import Events from './event-emitter';\n\n/**\n * Helper class for handling RPC calls\n */\nclass RPCResolver {\n  constructor(id, resolve, reject) {\n    Events.mixin(this);\n    this.id = id;\n    this.resolve = resolve;\n    this.reject = reject;\n  }\n  resolveWith(data) {\n    this.resolve(data);\n    this.emit('resolved', this.id);\n  }\n  rejectWith(err) {\n    this.reject(err);\n    this.emit('rejected', this.id);\n  }\n}\n\nexport default RPCResolver;\n","import Events from './event-emitter';\nimport RPCResolver from './rpc-resolver';\n\n/**\n* This class handles remote procedure calls on a web socket.\n*/\nclass RPC {\n\n  /**\n  * Create a new RPC instance.\n  * @param {Object} options The configuration options for this class.\n  * @param {Function} options.Promise The promise constructor to use.\n  * @param {String} options.url The complete websocket URL used to connect.\n  * @param {Function} options.createSocket The function callback to create a WebSocket.\n  */\n  constructor(options) {\n    Object.assign(this, options);\n    Events.mixin(this);\n    this.resolvers = {};\n    this.requestId = 0;\n    this.openedPromise = undefined;\n  }\n\n  /**\n  * Opens a connection to the configured endpoint.\n  * @param {Boolean} force - ignores all previous and outstanding open calls if set to true.\n  * @returns {Object} A promise instance.\n  */\n  open(force = false) {\n    if (!force && this.openedPromise) {\n      return this.openedPromise;\n    }\n\n    try {\n      this.socket = this.createSocket(this.url);\n    } catch (err) {\n      return this.Promise.reject(err);\n    }\n\n    this.socket.onopen = this.onOpen.bind(this);\n    this.socket.onclose = this.onClose.bind(this);\n    this.socket.onerror = this.onError.bind(this);\n    this.socket.onmessage = this.onMessage.bind(this);\n    this.openedPromise = new this.Promise((resolve, reject) => this.registerResolver('opened', resolve, reject));\n    this.closedPromise = new this.Promise((resolve, reject) => this.registerResolver('closed', resolve, reject));\n    return this.openedPromise;\n  }\n\n  /**\n  * Reopens the connection and waits for the OnConnected notification.\n  * @param {Number} timeout - The time to wait for the OnConnected notification.\n  * @returns {Object} A promise containing the session state (SESSION_CREATED or SESSION_ATTACHED).\n  */\n  reopen(timeout) {\n    let timer;\n    let notificationResolve;\n    let notificationReceived = false;\n    const notificationPromise = new this.Promise((resolve) => { notificationResolve = resolve; });\n\n    const waitForNotification = () => {\n      if (!notificationReceived) {\n        timer = setTimeout(() => notificationResolve('SESSION_CREATED'), timeout);\n      }\n      return notificationPromise;\n    };\n\n    const onNotification = (data) => {\n      if (data.method !== 'OnConnected') return;\n      clearTimeout(timer);\n      notificationResolve(data.params.qSessionState);\n      notificationReceived = true;\n    };\n\n    this.on('notification', onNotification);\n\n    return this.open(true)\n      .then(waitForNotification)\n      .then((state) => {\n        this.removeListener('notification', onNotification);\n        return state;\n      })\n      .catch((err) => {\n        this.removeListener('notification', onNotification);\n        return this.Promise.reject(err);\n      });\n  }\n\n  /**\n  * Resolves the open promise when a connection is successfully established.\n  */\n  onOpen() {\n    this.resolvers.opened.resolveWith(\n      () => this.closedPromise,\n    );\n  }\n\n  /**\n  * Resolves the close promise when a connection is closed.\n  * @param {Object} event - The event describing close.\n  */\n  onClose(event) {\n    this.emit('closed', event);\n    this.resolvers.closed.resolveWith(event);\n    this.rejectAllOutstandingResolvers({ code: -1, message: 'Socket closed' });\n  }\n\n  /**\n  * Closes a connection.\n  * @param {Number} [code=1000] - The reason code for closing the connection.\n  * @param {String} [reason=\"\"] - The human readable string describing why the connection is closed.\n  * @returns {Object} Returns a promise instance.\n  */\n  close(code = 1000, reason = '') {\n    this.socket.close(code, reason);\n    this.socket = null;\n    return this.closedPromise;\n  }\n\n  /**\n  * Emits an error event and rejects the open promise if an error is raised on the connection.\n  * @param {Object} event - The event describing the error.\n  */\n  onError(event) {\n    if (this.resolvers.opened) {\n      this.resolvers.opened.rejectWith(event);\n    } else {\n      // only emit errors after the initial open promise has been resolved,\n      // this makes it possible to catch early websocket errors as well\n      // as run-time ones:\n      this.emit('socket-error', event);\n    }\n    this.rejectAllOutstandingResolvers({ code: -1, message: 'Socket error' });\n  }\n\n  /**\n  * Parses the onMessage event on the connection and resolve the promise for the request.\n  * @param {Object} event - The event describing the message.\n  */\n  onMessage(event) {\n    const data = JSON.parse(event.data);\n    this.emit('traffic', 'received', data);\n    if (typeof data.id !== 'undefined') {\n      this.emit('message', data);\n      this.resolvers[data.id].resolveWith(data);\n    } else {\n      this.emit(data.params ? 'notification' : 'message', data);\n    }\n  }\n\n  /**\n  * Rejects all outstanding resolvers.\n  * @param {Object} reason - The reject reason.\n  */\n  rejectAllOutstandingResolvers(reason) {\n    Object.keys(this.resolvers).forEach((id) => {\n      if (id === 'opened' || id === 'closed') {\n        return; // \"opened\" and \"closed\" should not be handled here\n      }\n      const resolver = this.resolvers[id];\n      resolver.rejectWith(reason);\n    });\n  }\n\n  /**\n  * Unregisters a resolver.\n  * @param {Number|String} id - The ID to unregister the resolver with.\n  */\n  unregisterResolver(id) {\n    const resolver = this.resolvers[id];\n    resolver.removeAllListeners();\n    delete this.resolvers[id];\n  }\n\n  /**\n  * Registers a resolver.\n  * @param {Number|String} id - The ID to register the resolver with.\n  * @returns {Function} The promise executor function.\n  */\n  registerResolver(id, resolve, reject) {\n    const resolver = new RPCResolver(id, resolve, reject);\n    this.resolvers[id] = resolver;\n    resolver.on('resolved', resolvedId => this.unregisterResolver(resolvedId));\n    resolver.on('rejected', rejectedId => this.unregisterResolver(rejectedId));\n  }\n\n  /**\n  * Sends data on the socket.\n  * @param {Object} data - The data to send.\n  * @returns {Object} A promise instance.\n  */\n  send(data) {\n    if (!this.socket || this.socket.readyState !== this.socket.OPEN) {\n      return this.Promise.reject(new Error('Not connected'));\n    }\n    this.requestId += 1;\n    data.jsonrpc = '2.0';\n    data.id = this.requestId;\n    return new this.Promise((resolve, reject) => {\n      this.socket.send(JSON.stringify(data));\n      this.emit('traffic', 'sent', data);\n      return this.registerResolver(data.id, resolve, reject);\n    });\n  }\n}\n\nexport default RPC;\n","const ON_ATTACHED_TIMEOUT_MS = 5000;\nconst RPC_CLOSE_MANUAL_SUSPEND = 4000;\n\nclass SuspendResume {\n  /**\n  * Creates a new SuspendResume instance.\n  * @param {Object} options The configuration option for this class.\n  * @param {Promise} options.Promise The promise constructor to use.\n  * @param {RPC} options.rpc The RPC instance to use when communicating towards Engine.\n  * @param {ApiCache} options.apis The ApiCache instance to use.\n  */\n  constructor(options) {\n    Object.assign(this, options);\n    this.isSuspended = false;\n    this.rpc.on('traffic', (dir, data) => {\n      if (dir === 'sent' && data.method === 'OpenDoc') {\n        this.openDocParams = data.params;\n      }\n    });\n  }\n\n  /**\n  * Function used to restore the rpc connection.\n  * @param {Boolean} onlyIfAttached - if true, the returned promise will resolve\n  *                                   only if the session can be re-attached.\n  * @returns {Object} Returns a promise instance.\n  */\n  restoreRpcConnection(onlyIfAttached) {\n    return this.rpc.reopen(ON_ATTACHED_TIMEOUT_MS).then((sessionState) => {\n      if (sessionState === 'SESSION_CREATED' && onlyIfAttached) {\n        return this.Promise.reject(new Error('Not attached'));\n      }\n      return this.Promise.resolve();\n    });\n  }\n\n  /**\n  * Function used to restore the global API.\n  * @param {Object} changed - A list where the restored APIs will be added.\n  * @returns {Object} Returns a promise instance.\n  */\n  restoreGlobal(changed) {\n    const global = this.apis.getApisByType('Global').pop();\n    changed.push(global.api);\n    return this.Promise.resolve();\n  }\n\n  /**\n  * Function used to restore the doc API.\n  * @param {String} sessionState - The state of the session, attached or created.\n  * @param {Array} closed - A list where the closed of APIs APIs will be added.\n  * @param {Object} changed - A list where the restored APIs will be added.\n  * @returns {Object} Returns a promise instance.\n  */\n  restoreDoc(closed, changed) {\n    const doc = this.apis.getApisByType('Doc').pop();\n\n    if (!doc) {\n      return this.Promise.resolve();\n    }\n\n    return this.rpc.send({\n      method: 'GetActiveDoc',\n      handle: -1,\n      params: [],\n    }).then((response) => {\n      if (response.error && this.openDocParams) {\n        return this.rpc.send({\n          method: 'OpenDoc',\n          handle: -1,\n          params: this.openDocParams,\n        });\n      }\n      return response;\n    }).then((response) => {\n      if (response.error) {\n        closed.push(doc.api);\n        return this.Promise.resolve();\n      }\n      const handle = response.result.qReturn.qHandle;\n      doc.api.handle = handle;\n      changed.push(doc.api);\n      return this.Promise.resolve(doc.api);\n    });\n  }\n\n  /**\n  * Function used to restore the APIs on the doc.\n  * @param {Object} doc - The doc API on which the APIs we want to restore exist.\n  * @param {Array} closed - A list where the closed of APIs APIs will be added.\n  * @param {Object} changed - A list where the restored APIs will be added.\n  * @returns {Object} Returns a promise instance.\n  */\n  restoreDocObjects(doc, closed, changed) {\n    const tasks = [];\n    const apis = this.apis.getApis()\n        .map(entry => entry.api)\n        .filter(api => api.type !== 'Global' && api.type !== 'Doc');\n\n    if (!doc) {\n      apis.forEach(api => closed.push(api));\n      return this.Promise.resolve();\n    }\n\n    apis.forEach((api) => {\n      const method = SuspendResume.buildGetMethodName(api.type);\n\n      if (!method) {\n        closed.push(api);\n      } else {\n        const request = this.rpc.send({\n          method,\n          handle: doc.handle,\n          params: [api.id],\n        }).then((response) => {\n          if (response.error || !response.result.qReturn.qHandle) {\n            closed.push(api);\n          } else {\n            api.handle = response.result.qReturn.qHandle;\n            changed.push(api);\n          }\n        });\n        tasks.push(request);\n      }\n    });\n    return this.Promise.all(tasks);\n  }\n\n  /**\n  * Set the instance as suspended.\n  */\n  suspend() {\n    this.isSuspended = true;\n    return this.rpc.close(RPC_CLOSE_MANUAL_SUSPEND);\n  }\n\n  /**\n  * Resumes a previously suspended RPC connection, and refreshes the API cache.\n  *                                APIs unabled to be restored has their 'closed'\n  *                                event triggered, otherwise 'changed'.\n  * @param {Boolean} onlyIfAttached if true, resume only if the session was re-attached.\n  * @returns {Promise} Eventually resolved if the RPC connection was successfully resumed,\n  *                    otherwise rejected.\n  */\n  resume(onlyIfAttached) {\n    const changed = [];\n    const closed = [];\n\n    return this.restoreRpcConnection(onlyIfAttached)\n      .then(() => this.restoreGlobal(changed))\n      .then(() => this.restoreDoc(closed, changed))\n      .then(doc => this.restoreDocObjects(doc, closed, changed))\n      .then(() => {\n        this.isSuspended = false;\n        this.apis.clear();\n        closed.forEach((api) => {\n          api.emit('closed');\n          api.removeAllListeners();\n        });\n        changed.forEach((api) => {\n          this.apis.add(api.handle, api);\n          if (api.type !== 'Global') {\n            api.emit('changed');\n          }\n        });\n      })\n      .catch(err => this.rpc.close().then(() => this.Promise.reject(err)));\n  }\n\n  /**\n  * Function used to build the get method names for Doc APIs.\n  * @param {String} type - The API type.\n  * @returns {String} Returns the get method name, or undefined if the type cannot be restored.\n  */\n  static buildGetMethodName(type) {\n    if (type === 'Field' || type === 'Variable') {\n      return null;\n    } else if (type === 'GenericVariable') {\n      return 'GetVariableById';\n    }\n    return type.replace('Generic', 'Get');\n  }\n}\n\nexport default SuspendResume;\n","const RETURN_KEY = 'qReturn';\n\nclass Intercept {\n  /**\n  * Create a new Intercept instance.\n  * @param {Object} options The configuration options for this class.\n  * @param {Promise} options.Promise The promise constructor to use.\n  * @param {ApiCache} options.apis The ApiCache instance to use.\n  * @param {Boolean} options.delta Whether to use the delta protocol.\n  * @param {Array} [options.interceptors] Additional interceptors to use.\n  * @param {JSONPatch} [options.JSONPatch] The JSONPatch implementation to use (for testing).\n  */\n  constructor(options) {\n    Object.assign(this, options);\n    this.interceptors = [{\n      onFulfilled: this.processErrorInterceptor,\n    }, {\n      onFulfilled: this.processDeltaInterceptor,\n    }, {\n      onFulfilled: this.processResultInterceptor,\n    }, {\n      onFulfilled: this.processMultipleOutParamInterceptor,\n    }, {\n      onFulfilled: this.processOutInterceptor,\n    }, ...this.interceptors || []];\n  }\n\n  /**\n  * Function used to determine if it is a primitive patch.\n  * @param  {Array}  patches Patches from engine.\n  * @return {Boolean} Returns true if it is a primitive patch.\n  */\n  isPrimitivePatch(patches) {\n    // It's only `add` and `replace` that has a\n    // value property according to the jsonpatch spec\n    return patches.length === 1 &&\n    ['add', 'replace'].indexOf(patches[0].op) !== -1 &&\n    this.isPrimitiveValue(patches[0].value) &&\n    patches[0].path === '/';\n  }\n\n  /**\n  * Function used to determine if it is a primitive value.\n  * @param  {Any} value.\n  * @return {Boolean} Returns true if it is a primitive value.\n  */\n  isPrimitiveValue(value) {\n    return typeof value !== 'undefined' && value !== null && typeof value !== 'object' && !Array.isArray(value);\n  }\n\n  /**\n  * Function used to get a patchee.\n  * @param {Number} handle - The handle.\n  * @param {Array} patches - The patches.\n  * @param {String} cacheId - The cacheId.\n  * @returns {Object} Returns the patchee.\n  */\n  getPatchee(handle, patches, cacheId) {\n    // handle primitive types, e.g. string, int, bool\n    if (this.isPrimitivePatch(patches)) {\n      const value = patches[0].value;\n      this.apis.setPatchee(handle, cacheId, value);\n      return value;\n    }\n\n    let patchee = this.apis.getPatchee(handle, cacheId);\n\n    if (!this.isPrimitiveValue(patchee)) {\n      patchee = patchee || (patches.length && Array.isArray(patches[0].value) ? [] : {});\n      this.applyPatch(patchee, patches);\n    }\n\n    this.apis.setPatchee(handle, cacheId, patchee);\n\n    return patchee;\n  }\n\n  /**\n  * Function used to apply a patch.\n  * @param {Object} patchee - The object to patch.\n  * @param {Array} patches - The list of patches to apply.\n  */\n  applyPatch(patchee, patches) {\n    this.JSONPatch.apply(patchee, patches);\n  }\n\n  /**\n  * Process error interceptor.\n  * @param {Object} meta - The meta info about the request.\n  * @param response - The response.\n  * @returns {Object} - Returns the defined error for an error, else the response.\n  */\n  processErrorInterceptor(meta, response) {\n    if (typeof response.error !== 'undefined') {\n      return this.Promise.reject(response.error);\n    }\n    return response;\n  }\n\n  /**\n  * Process delta interceptor.\n  * @param {Object} meta - The meta info about the request.\n  * @param response - The response.\n  * @returns {Object} - Returns the patched response\n  */\n  processDeltaInterceptor(meta, response) {\n    const result = response.result;\n    if (response.delta) {\n      // when delta is on the response data is expected to be an array of patches\n      const keys = Object.keys(result);\n      for (let i = 0, cnt = keys.length; i < cnt; i += 1) {\n        const key = keys[i];\n        const patches = result[key];\n        if (!Array.isArray(patches)) {\n          return this.Promise.reject('Unexpected rpc response, expected array of patches');\n        }\n        result[key] = this.getPatchee(meta.handle, patches, `${meta.method}-${key}`);\n      }\n      // return a cloned response object to avoid patched object references:\n      return JSON.parse(JSON.stringify(response));\n    }\n    return response;\n  }\n\n  /**\n  * Process result interceptor.\n  * @param {Object} meta - The meta info about the request.\n  * @param response - The response.\n  * @returns {Object} - Returns the result property on the response\n  */\n  processResultInterceptor(meta, response) {\n    return response.result;\n  }\n\n  /**\n  * Processes specific QIX methods that are breaking the protocol specification\n  * and normalizes the response.\n  * @param {Object} meta - The meta info about the request.\n  * @param response - The response.\n  * @returns {Object} - Returns the result property on the response\n  */\n  processMultipleOutParamInterceptor(meta, response) {\n    if (meta.method === 'CreateSessionApp' || meta.method === 'CreateSessionAppFromApp') {\n      // this method returns multiple out params that we need\n      // to normalize before processing the response further:\n      response[RETURN_KEY].qGenericId = response[RETURN_KEY].qGenericId || response.qSessionAppId;\n    } else if (meta.method === 'GetInteract') {\n      // this method returns a qReturn value when it should only return\n      // meta.outKey:\n      delete response[RETURN_KEY];\n    }\n    return response;\n  }\n\n  /**\n  * Process out interceptor.\n  * @param {Object} meta - The meta info about the request.\n  * @param response - The result.\n  * @returns {Object} - Returns the out property on result\n  */\n  processOutInterceptor(meta, response) {\n    if (hasOwnProperty.call(response, RETURN_KEY)) {\n      return response[RETURN_KEY];\n    } else if (meta.outKey !== -1) {\n      return response[meta.outKey];\n    }\n    return response;\n  }\n\n  /**\n  * Execute the interceptor queue, each interceptor will get the result from\n  * the previous interceptor.\n  * @param {Promise} promise The promise to chain on to.\n  * @param {Object} meta The JSONRPC request object for the intercepted response.\n  * @returns {Promise}\n  */\n  execute(promise, meta) {\n    return this.interceptors.reduce((interception, interceptor) =>\n      interception.then(\n      interceptor.onFulfilled && interceptor.onFulfilled.bind(this, meta),\n      interceptor.onRejected && interceptor.onRejected.bind(this, meta))\n      , promise,\n    );\n  }\n}\n\nexport default Intercept;\n","import KeyValueCache from './cache';\n\n/**\n* API cache for instances of QIX types, e.g. GenericObject.\n* @extends KeyValueCache\n*/\nclass ApiCache extends KeyValueCache {\n\n  /**\n  * Event handler for triggering API instance events when their handle\n  * is changed.\n  * @emits api#changed\n  */\n  onHandleChanged(handle) {\n    const api = this.getApi(handle);\n    if (api) {\n      api.emit('changed');\n    }\n  }\n\n  /**\n  * Event handler for triggering API instance events when their handle\n  * is closed.\n  * @emits api#closed\n  */\n  onHandleClosed(handle) {\n    const api = this.getApi(handle);\n    if (api) {\n      api.emit('closed');\n      this.remove(handle);\n    }\n  }\n\n  /**\n  * Event handler for cleaning up API instances when a session has been closed.\n  * @emits api#closed\n  */\n  onSessionClosed() {\n    this.getApis().forEach((entry) => {\n      entry.api.emit('closed');\n      entry.api.removeAllListeners();\n    });\n    this.clear();\n  }\n\n  /**\n  * Adds an API.\n  * @function ApiCache#add\n  * @param {Number} handle - The handle for the API.\n  * @param {*} api - The API.\n  * @returns {{api: *, deltaCache}} The entry.\n  */\n  add(handle, api) {\n    const entry = {\n      api,\n      deltaCache: new KeyValueCache(),\n    };\n    super.add(handle.toString(), entry);\n    return entry;\n  }\n\n  /**\n  * Gets an API.\n  * @function ApiCache#getApi\n  * @param {Number} handle - The handle for the API.\n  * @returns {*} The API for the handle.\n  */\n  getApi(handle) {\n    const entry = typeof handle !== 'undefined' ? this.get(handle.toString()) : undefined;\n    return entry && entry.api;\n  }\n\n  /**\n  * Gets a list of APIs.\n  * @function ApiCache#getApis\n  * @returns {Array} The list of entries including `handle` and `api` properties for each entry.\n  */\n  getApis() {\n    return super.getAll().map(entry =>\n      ({\n        handle: entry.key,\n        api: entry.value.api,\n      }),\n    );\n  }\n\n  /**\n  * Gets a list of APIs with a given type.\n  * @function ApiCache#getApisByType\n  * @param {String} type - The type of APIs to get.\n  * @returns {Array} The list of entries including `handle` and `api` properties for each entry.\n  */\n  getApisByType(type) {\n    return this.getApis().filter(entry => entry.api.type === type);\n  }\n\n  /**\n  * Gets a patchee.\n  * @function ApiCache#getPatchee\n  * @param {Number} handle - The handle for the API to patch.\n  * @param {String} method - The method to patch.\n  * @returns {*} The patchee.\n  */\n  getPatchee(handle, method) {\n    const entry = this.get(handle.toString());\n    return entry && entry.deltaCache.get(method);\n  }\n\n  /**\n  * Adds a patchee.\n  * @function ApiCache#addPatchee\n  * @param {Number} handle - The handle for the API to patch.\n  * @param {String} method - The method to patch.\n  * @param {Object} patchee - The patchee to add.\n  */\n  addPatchee(handle, method, patchee) {\n    this.get(handle.toString()).deltaCache.add(method, patchee);\n  }\n\n  /**\n  * Sets a patchee.\n  * @function ApiCache#setPatchee\n  * @param {Number} handle - The handle for the API.\n  * @param {String} method - The method.\n  * @param {Object} patchee - The patchee to add.\n  */\n  setPatchee(handle, method, patchee) {\n    this.get(handle.toString()).deltaCache.set(method, patchee);\n  }\n}\n\nexport default ApiCache;\n","import Patch from './json-patch';\nimport Session from './session';\nimport Schema from './schema';\nimport RPC from './rpc';\nimport SuspendResume from './suspend-resume';\nimport Intercept from './intercept';\nimport ApiCache from './api-cache';\n\n/**\n* Qix service.\n*/\nclass Qix {\n\n  /**\n  * Function used to get a session.\n  * @param {Configuration} config The configuration object for this session.\n  * @returns {Object} Returns a session instance.\n  */\n  static getSession(config) {\n    const {\n      createSocket,\n      definition,\n      JSONPatch,\n      Promise,\n      protocol,\n      responseInterceptors,\n      url,\n    } = config;\n    const apis = new ApiCache();\n    const intercept = new Intercept({\n      apis,\n      interceptors: responseInterceptors,\n      JSONPatch,\n      Promise,\n    });\n    const rpc = new RPC({ createSocket, Promise, url });\n    const suspendResume = new SuspendResume({ apis, Promise, rpc });\n    const session = new Session({\n      apis,\n      definition,\n      intercept,\n      Promise,\n      protocol,\n      rpc,\n      suspendResume,\n    });\n    return session;\n  }\n\n  /**\n  * Function used to create a QIX session.\n  * @param {Object} config The configuration object for the QIX session.\n  * @returns {Session} Returns a new QIX session.\n  */\n  static create(config) {\n    Qix.configureDefaults(config);\n    config.mixins.forEach((mixin) => {\n      config.definition.registerMixin(mixin);\n    });\n    return Qix.getSession(config);\n  }\n\n  /**\n  * Function used to configure defaults.\n  * @param {Configuration} config The configuration object for how to connect\n  *                               and retrieve end QIX APIs.\n  */\n  static configureDefaults(config) {\n    if (!config) {\n      throw new Error('You need to supply a configuration.');\n    }\n\n    if (!config.Promise && typeof Promise === 'undefined') { // eslint-disable-line no-restricted-globals\n      throw new Error('Your environment has no Promise implementation. You must provide a Promise implementation in the config.');\n    }\n\n    if (typeof config.createSocket !== 'function' && typeof WebSocket === 'function') {\n      config.createSocket = url => new WebSocket(url); // eslint-disable-line no-undef\n    }\n\n    if (typeof config.suspendOnClose === 'undefined') {\n      config.suspendOnClose = false;\n    }\n\n    config.protocol = config.protocol || {};\n    config.protocol.delta = config.protocol.delta || true;\n    config.Promise = config.Promise || Promise; // eslint-disable-line no-restricted-globals\n    config.mixins = config.mixins || [];\n    config.JSONPatch = config.JSONPatch || Patch;\n    config.definition = config.definition || new Schema(config);\n  }\n}\n\nexport default Qix;\n"],"names":["isObject","v","Array","isArray","isUndef","isFunction","generateValue","val","extend","isSpecialProperty","obj","key","substring","getParent","data","str","parts","split","slice","numPart","forEach","part","i","length","newPart","isNaN","emptyObject","keys","Object","getOwnPropertyDescriptor","configurable","compare","a","b","isIdentical","l","patchArray","original","newA","basePath","findIndex","id","idx","qInfo","qId","ii","ll","patches","oldA","tmpIdx","push","splice","concat","JSONPatch","generate","EventEmitter","init","call","this","toCamelCase","symbol","toLowerCase","namedParamFacade","base","defaults","params","babelHelpers.typeof","every","hasOwnProperty","map","apply","hasOwn","prototype","toStr","toString","arr","isPlainObject","hasOwnConstructor","hasIsPrototypeOf","constructor","options","name","src","copy","copyIsArray","clone","target","arguments","deep","bind","newData","oldVal","tmpPath","patch","parent","path","from","op","value","newValues","Error","oldParent","createPatch","updateObject","util","arg","isNumber","isUndefined","_events","undefined","_maxListeners","defaultMaxListeners","setMaxListeners","n","TypeError","emit","type","er","handler","len","args","listeners","error","addListener","listener","newListener","warned","m","console","trace","on","once","g","removeListener","fired","list","position","removeAllListeners","listenerCount","emitter","Session","session","mixin","rpc","onError","onClosed","onMessage","onNotification","onTraffic","apis","onHandleChanged","handle","onHandleClosed","onSessionClosed","err","suspendResume","isSuspended","evt","code","suspendOnClose","suspend","then","_this","initiator","response","change","_this2","close","method","dir","customType","api","getApi","definition","create","protocol","delta","add","qHandle","qType","getObjectApi","qGenericId","qGenericType","Promise","reject","globalPromise","open","_this3","global","request","babelHelpers.extends","send","promise","intercept","execute","res","_this4","handleObjectReferenceResponse","addToPromiseChain","_this5","onlyIfAttached","resume","_this7","chain","KeyValueCache","entries","entry","filter","IGNORE_DELTA_METHODS","Schema","config","schema","mixins","types","override","cached","typeKey","entryList","get","structs","factory","generateApi","generateDefaultApi","mixinType","mixinNamedParamFacade","customKey","instance","defineProperties","mixinList","fnName","outKey","Out","Name","allowDelta","indexOf","defineProperty","baseFn","In","reduce","result","item","DefaultValue","RPCResolver","resolve","RPC","resolvers","requestId","openedPromise","socket","createSocket","url","onopen","onOpen","onclose","onClose","onerror","onmessage","registerResolver","closedPromise","timeout","timer","notificationResolve","notificationReceived","notificationPromise","qSessionState","setTimeout","state","catch","opened","resolveWith","event","closed","rejectAllOutstandingResolvers","message","reason","rejectWith","JSON","parse","resolver","unregisterResolver","resolvedId","rejectedId","readyState","OPEN","jsonrpc","stringify","_this6","SuspendResume","openDocParams","reopen","sessionState","changed","getApisByType","pop","doc","qReturn","tasks","getApis","buildGetMethodName","all","restoreRpcConnection","restoreGlobal","restoreDoc","restoreDocObjects","clear","replace","Intercept","interceptors","processErrorInterceptor","processDeltaInterceptor","processResultInterceptor","processMultipleOutParamInterceptor","processOutInterceptor","isPrimitiveValue","cacheId","isPrimitivePatch","setPatchee","patchee","getPatchee","applyPatch","meta","cnt","qSessionAppId","interception","interceptor","onFulfilled","onRejected","ApiCache","remove","babelHelpers.get","deltaCache","set","responseInterceptors","configureDefaults","registerMixin","Qix","getSession","WebSocket","Patch"],"mappings":"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"}